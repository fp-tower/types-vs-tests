<!DOCTYPE html>
<html>
  <head>
    <title>Types vs Tests</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .pull-left {
      float: left;
      width: 47%;
      }
      .pull-right {
      float: right;
      width: 47%;
      }
      table {
      border-collapse: collapse;
      }
      th, td {
      padding: 10px;
      border: 1px solid black;
      }
      tr:nth-child(even) {background-color: #f2f2f2;}
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Types vs Tests
`@JulienTruffaut`

---
class: center, middle

# Types

---
background-image: url(img/types-1.jpg)

# Types

---
background-image: url(img/types-2.jpg)

# Types

---
background-image: url(img/types-3.jpg)

# Types

---
# Values

```tut:silent
val x: Int = 5

val foo: Boolean = true
```

--

```tut:fail
val y: Int = false
```

---
background-image: url(img/function.jpg)

# Function

---
# Functional programming subset

* deterministic
* total
* no side effect
* no mutation
* no exception
* no null
* no reflection

---
# Function

```tut:silent
def increment(x: Int): Int = x + 1
```

--

```tut
increment(2)
increment(-5)
```

--

```tut:fail
increment("hello")
```

---
class: center, middle

# Tests

---
class: center, middle

# Unit Test

---
# Unit Test

```tut:silent
increment( 0) ==  1
increment( 1) ==  2
increment(-3) == -2
```

---
background-image: url(img/increment-math-unit-test-1.jpg)

# Unit Test

---
background-image: url(img/increment-math-unit-test-fail.jpg)

# Unit Test

---
background-image: url(img/increment-math-unit-test-2.jpg)

# Unit Test

---
class: center, middle

# Property Test

---
# Property Test

```tut:silent
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers

class IncrementTest extends FreeSpec with Checkers {

  "f(x) > x" in check((x: Int) => increment(x) > x)

}
```

---
background-image: url(img/increment-math-property-test-1.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-2.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-fail.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-3.jpg)
# Property Test

---
# Property Test: edge cases

```tut:silent
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers

class IncrementTest extends FreeSpec with Checkers {

  "f(x) > x" in check((x: Int) => increment(x) > x)

}
```

--

```scala
GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.
 (IncrementTest.scala:10)
  Falsified after 4 successful property evaluations.
  Location: (IncrementTest.scala:10)
  Occurred when passed generated values (
    arg0 = 2147483647
  )
```

```tut
increment(2147483647)
```

---
# Property Test: edge cases


```tut:silent
def increment(x: Int): Int = {
  if(x < Int.MaxValue) x + 1
  else x
}
```

```tut
increment(5)
increment(2147483647)
```

---
# Property Test: refinement types

```tut:silent
import eu.timepit.refined.numeric.Less
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers
import eu.timepit.refined.W
import eu.timepit.refined.api.Refined
import eu.timepit.refined.scalacheck.numeric._

class IncrementTest extends FreeSpec with Checkers {

  final val maxInt = Int.MaxValue

  "f(x) > x" in check((x: Int Refined Less[W.`maxInt`.T]) =>
    increment(x.value) > x.value
  )

}
```

---
class: center, middle

# Types and Tests

---

.pull-left[
# Types

```tut:fail
increment("hello")
```
]

.pull-right[
# Tests

```tut:silent
import org.scalacheck.Prop.forAll

increment(0) == 1

forAll((x: Int) => increment(x) > x)
```
]

---
class: center, middle

# Both types and tests constrain the implementation of a function

---
class: center, middle

# How much?

---
class: center, middle

# A => B

---
class: middle

```tut:silent
val isEven: Int => Boolean =
  x => x % 2 == 0

val increment: Int => Int =
  x => x + 1
```

---
background-image: url(img/A-to-B-set-1.jpg)

# Functions are sets!

---
background-image: url(img/A-to-B-set-2.jpg)

# Functions are sets!


---
background-image: url(img/int-to-int-type-1.jpg)

# Functions are sets!

---
background-image: url(img/int-to-int-type-test.jpg)

# Tests

---
class: center, middle

# How to constrain a function?

---
background-image: url(img/A-to-B-constrain.jpg)

# Constraints

---
class: center, middle

# Smaller types


---
background-image: url(img/function-one-value.jpg)

# Function with one implementation

---
class: middle

```tut:silent
def boolToUnit(x: Boolean): Unit = x match {
  case true  => ()
  case false => ()
}
```

---
class: middle

```tut:silent
def toUnit[A](x: A): Unit = ()
```

---
class: center, middle

# |A => B| ?

---
background-image: url(img/function.jpg)

# Function is a mapping

---
background-image: url(img/function-mapping-1.jpg)

# Function is a mapping

---
background-image: url(img/count-A-to-B-1.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-2.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-3.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-4.jpg)

# |A => B|

---
class: center, middle

```scala
|Int => Int| = |Int| ^ |Int|
               = (2^32) ^ (2^32)
```

--

```scala
|DayOfWeek => Boolean| = |Boolean| ^ |DayOfWeek|
     = 2 ^ 7
   = 128
```

---
class: center, middle

# More tests

---
background-image: url(img/day-week-to-boolean-1.jpg)

---
class: center, middle

# How many implementations a single unit test renders invalid?

---
background-image: url(img/day-week-to-boolean-2.jpg)

---
# Unit test

```scala
val f: DayOfWeek => Boolean = ???
```

such as

```scala
isWeekend(Tuesday) == false
```

---
background-image: url(img/count-day-week-to-boolean-1.jpg)

# Unit Test

---
background-image: url(img/count-day-week-to-boolean-2.jpg)

# Unit Test

---
background-image: url(img/count-day-week-to-boolean-3.jpg)

# Unit Test

---
background-image: url(img/count-day-week-to-boolean-4.jpg)

# Unit Test

---
# Unit Test

| Unit test     | Valid implementations |
| :-----------: |:---------------------:|
| 0             | 128                   |
| 1             | 64                    |
| 2             | 32                    |
| 3             | 16                    |
| 4             |  8                    |
| 5             |  4                    |
| 6             |  2                    |
| 7             |  1                    |


---
class: center, middle

# A unit test divides the size of |A => B| by |B|

---
class: center, middle

# A function A => B requires `|A|` unit tests to be fully covered

---
class: middle

## 1. Functions are sets

## 2. Functions are constrained by using smaller types or more tests

## 3. `|A => B| = |B| ^ |A|`

## 4. Each unit test divides by `|B|` the number of valid implementations

## 5. A function requires `|A|` unit tests to be fully tested

---
# Example: dialCode

```tut:silent
def getDialCode(country: String): Int = ???
```

such as

```scala
getDialCode("United Kingdom") == 44
getDialCode("France")         == 33
```

---
# Example: dialCode

```tut:silent
def getDialCode(country: String): Int = country match {
  case "United Kingdom" => 44
  case "France"         => 33
  case _                => ???
}
```

--

```tut
getDialCode("United Kingdom")
getDialCode("France")
```

--

```tut:fail
getDialCode("Italy")
```

---
# Example: dialCode

```tut:silent
def getDialCode(country: String): Option[Int] = country match {
  case "United Kingdom" => Some(44)
  case "France"         => Some(33)
  case _                => None
}
```

--

```tut
getDialCode("United Kingdom")
getDialCode("France")
getDialCode("Italy")
```

--

```tut
getDialCode("UK")
getDialCode("Royaume Uni")
```

---
# Example: dialCode

```tut:silent
sealed trait Country

case object UnitedKingdom extends Country
case object France extends Country
```

--

```tut:silent
def getDialCode(country: Country): Int = country match {
  case UnitedKingdom => 44
  case France        => 33
}
```

--

```tut
getDialCode(UnitedKingdom)
```

```tut:fail
getDialCode(Italy)
```

---
# Example: dialCode

```tut:silent
sealed trait Country

case object UnitedKingdom extends Country
case object France extends Country
case object Italy extends Country
```

```tut:silent
def getDialCode(country: Country): Int = country match {
  case UnitedKingdom => 44
  case France        => 33
}
```

--

```scala
Warning:(11, 44) match may not be exhaustive.
It would fail on the following input: Italy
  def getDialCode(country: Country): Int = country match {
```

---
# Example: dialCode

```tut:silent
def parseCountry(x: String): Option[Country] = ???
```

such as

```scala
parseCountry("United Kingdom") == Some(UnitedKingdom)
parseCountry("UK")             == Some(UnitedKingdom)
```

---
# Example: dialCode

```scala
|String => Option[Int]| = |Option[Int]| ^ |String|
                        = (|Int| + 1) ^ |String|
```

--

```scala
|Country => Int| = |Int| ^ |Country|
                 = |Int| ^ 2
```

--

```scala
|Country => DialCode| = |DialCode| ^ |Country|
                      = 2 ^ 2
                      = 4
```

---
# Example: dialCode

```tut:silent
sealed trait DialCode

object _33 extends DialCode
object _44 extends DialCode
```

--

```tut:silent
def getDialCode(country: Country): DialCode = country match {
  case UnitedKingdom => _44
  case France        => _33
}
```

--

```tut:silent
def getCountry(dialCode: DialCode): Country = dialCode match {
  case _33 => France
  case _44 => France
}
```

---
# Example: dialCode

```tut
getDialCode(France)
getCountry(_33)
```

--

```tut:invisible
import org.scalacheck.{Arbitrary, Gen}

implicit val arbCountry: Arbitrary[Country] = Arbitrary(Gen.oneOf(UnitedKingdom, France))
```

```tut:silent
class DialCodeTest extends FreeSpec with Checkers {

  "round trip" in check((x: Country) =>
    getCountry(getDialCode(x)) == x
  )

}
```

--

```scala
GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.
 (DialCodeTest.scala:10)
  Falsified after 2 successful property evaluations.
  Location: (DialCodeTest.scala:10)
  Occurred when passed generated values (
    arg0 = UnitedKingdom
  )
```

---
# Example: Compare

```tut:silent
def compare(x: Int, y: Int): Int = {
  if(x < y)        -1
  else if (x == y)  0
  else              1
}
```

---
# Example: Compare

```tut:silent
sealed trait Comparison

case object LowerThan   extends Comparison
case object EqualTo     extends Comparison
case object GreaterThan extends Comparison

def compare(x: Int, y: Int): Comparison = {
  if(x < y)        LowerThan
  else if (x == y) EqualTo
  else             GreaterThan
}
```

---
# Example: Person

```tut:silent
case class Person(name: String, age: Int)
```

--

```tut
Person("John", 25)
Person("Alice", 12)
Person("George", -2)
```

---
# Example: Person with refinement types

```tut:silent
import eu.timepit.refined._
import eu.timepit.refined.api.Refined
import eu.timepit.refined.auto._
import eu.timepit.refined.numeric._

type PosInt = Int Refined Positive

case class Person(name: String, age: PosInt)
```

--

```tut
Person("John", 25)
Person("Alice", 12)
```

```tut:fail
Person("George", -2)
```

---
# Conclusion

## Both tests and types give us more correct program

## Smaller are the types, less tests are required

## Unit / Property based tests cover the rest

---
# Next level: Parametricity

```tut:silent
def mapInt(fa: Option[Int])(f: Int => Int): Option[Int] = ???

def map[A, B](fa: Option[A])(f: A => B): Option[B] = ???
```

---
class: center, middle

# Thanks!
Code and slides at `julien-truffaut/types-vs-tests` on GitHub

## Questions?

 </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
        var slideshow = remark.create({
            ratio: "16:9"
        });
    </script>
  </body>
</html>
