<!DOCTYPE html>
<html>
  <head>
    <title>Types vs Tests</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .pull-left {
      float: left;
      width: 47%;
      }
      .pull-right {
      float: right;
      width: 47%;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Types vs Tests
`@JulienTruffaut`

---
class: center, middle

# Types

---
background-image: url(img/types-1.jpg)

# Types

---
background-image: url(img/types-2.jpg)

# Types

---
background-image: url(img/types-3.jpg)

# Types

---
# Values

```tut:silent
val x: Int = 5

val foo: Boolean = true
```

--

```tut:fail
val y: Int = false
```

---
background-image: url(img/function.jpg)

# Function

---
# Functional programming subset

* deterministic
* total
* no side effect
* no mutation
* no exception
* no null
* no reflection

---
# Function

```tut:silent
def increment(x: Int): Int = x + 1
```

--

```tut
increment(2)
increment(-5)
```

--

```tut:fail
increment("hello")
```

---
class: center, middle

# Tests

---
class: center, middle

# Unit Tests

---
# Unit Tests

```tut:silent
increment( 0) ==  1
increment( 1) ==  2
increment(-3) == -2
```

---
background-image: url(img/increment-math-unit-test-1.jpg)

# Unit Test

---
background-image: url(img/increment-math-unit-test-fail.jpg)

# Unit Test

---
background-image: url(img/increment-math-unit-test-2.jpg)

# Unit Test

---
class: center, middle

# Property Test

---
# Property Test

```tut:silent
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers

class IncrementTest extends FreeSpec with Checkers {

  "f(x) > x" in check((x: Int) => increment(x) > x)

}
```

---
background-image: url(img/increment-math-property-test-1.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-2.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-fail.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-3.jpg)
# Property Test

---
# Property Test

```tut:silent
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers

class IncrementTest extends FreeSpec with Checkers {

  "f(x) > x" in check((x: Int) => increment(x) > x)

}
```

---
class: middle

```scala
GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.
 (IncrementTest.scala:10)
  Falsified after 4 successful property evaluations.
  Location: (IncrementTest.scala:10)
  Occurred when passed generated values (
    arg0 = 2147483647
  )
```

---
# Property Test

```tut:silent
import eu.timepit.refined.numeric.Less
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers
import eu.timepit.refined.W
import eu.timepit.refined.api.Refined
import eu.timepit.refined.scalacheck.numeric._

class IncrementTest extends FreeSpec with Checkers {

  final val maxInt = Int.MaxValue

  "f(x) > x" in check((x: Int Refined Less[W.`maxInt`.T]) =>
    increment(x.value) > x.value
  )

}
```

---
class: center, middle

# Types and Tests

---

.pull-left[
# Types

```tut:fail
increment("hello")
```
]

.pull-right[
# Tests

```tut:silent
import org.scalacheck.Prop.forAll

increment(0) == 1

forAll((x: Int) => increment(x) > x)
```
]

---
class: center, middle

# Both types and tests constrain the implementation of a function

---
class: center, middle

# How much?

---
class: center, middle

# A => B

---
class: middle

```tut:silent
val isEven: Int => Boolean =
  x => x % 2 == 0

val increment: Int => Int =
  x => x + 1
```

---
background-image: url(img/A-to-B-set.jpg)

# Functions are sets!

---
background-image: url(img/int-to-int-type-2.jpg)

# Functions are sets!

---
background-image: url(img/int-to-int-type-test-1.jpg)

# Unit tests

---
background-image: url(img/int-to-int-type-test-3.jpg)

# Unit + Property tests

---
class: center, middle

# Both types and tests constrain the implementation of a function

---
background-image: url(img/A-to-B-constrain.jpg)

# Constrain

---
background-image: url(img/int-to-int-type-fully-tested-1.jpg)

# Fully tested function

---
background-image: url(img/int-to-int-type-fully-tested-2.jpg)

# Fully tested function

---
class: center, middle

# A function A => B requires `|A|` unit tests to be fully covered

---
background-image: url(img/A-to-B-constrain.jpg)

# Constrain

---
background-image: url(img/function-one-value.jpg)

# Single value set

---
class: middle

```tut:silent
def boolToUnit(x: Boolean): Unit = ()
```

--

```tut:silent
def toUnit[A](x: A): Unit = ()
```

---
class: center, middle

# |A => B| ?

---
background-image: url(img/function.jpg)

# Function is a mapping

---
background-image: url(img/function-mapping-1.jpg)

# Function is a mapping

---
background-image: url(img/count-A-to-B-1.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-2.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-3.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-4.jpg)

# |A => B|

---
class: center, middle

```scala
|Int => Int| = |Int| ^ |Int|
               = (2^32) ^ (2^32)
```

--

```scala
|DayOfWeek => Boolean| = |Boolean| ^ |DayOfWeek|
     = 2 ^ 7
   = 128
```

---
class: middle

## 1. Functions are set

## 2. Function are constrained by more tests or smaller types

## 3. `|A => B| = |B| ^ |A|`


---
# Example: dialCode

```tut:silent
def getDialCode(country: String): Int = ???
```

such as

```scala
getDialCode("United Kinkdom") == 44
getDialCode("France")         == 33
```

---
# Example: dialCode

```tut:silent
def getDialCode(country: String): Int = country match {
  case "United Kinkdom" => 44
  case "France"         => 33
  case _                => ???
}
```

--

```tut
getDialCode("United Kinkdom")
getDialCode("France")
```

--

```tut:fail
getDialCode("Italy")
```

---
# Example: dialCode

```tut:silent
def getDialCode(country: String): Option[Int] = country match {
  case "United Kinkdom" => Some(44)
  case "France"         => Some(33)
  case _                => None
}
```

--

```tut
getDialCode("United Kinkdom")
getDialCode("France")
getDialCode("Italy")
```

--

```tut
getDialCode("UK")
getDialCode("Royaume Uni")
```

---
# Example: dialCode

```tut:silent
sealed trait Country

case object UnitedKingdom extends Country
case object France extends Country
```

--

```tut:silent
def getDialCode(country: Country): Int = country match {
  case UnitedKingdom => 44
  case France        => 33
}
```

--

```tut
getDialCode(UnitedKingdom)
```

```tut:fail
getDialCode(Italy)
```

---
# Example: dialCode

```tut:silent
sealed trait Country

case object UnitedKingdom extends Country
case object France extends Country
case object Italy extends Country
```

```tut:silent
def getDialCode(country: Country): Int = country match {
  case UnitedKingdom => 44
  case France        => 33
}
```

--

```scala
Warning:(11, 44) match may not be exhaustive.
It would fail on the following input: Italy
  def getDialCode(country: Country): Int = country match {
```

---
# Example: dialCode

```tut:silent
def parseCountry(x: String): Option[Country] = ???
```

such as

```scala
parseCountry("United Kingdom") == Some(UnitedKingdom)
parseCountry("UK")             == Some(UnitedKingdom)
```

---
# Example: dialCode

```scala
|String => Option[Int]| = |Option[Int]| ^ |String|
                        = (|Int| + 1) ^ |String|
```

--

```scala
|Country => Int| = |Int| ^ |Country|
                 = |Int| ^ 2
```

--

```scala
|Country => DialCode| = |DialCode| ^ |Country|
                      = 2 ^ 2
                      = 4
```

---
# Example: dialCode

```tut:silent
sealed trait DialCode

object _33 extends DialCode
object _44 extends DialCode
```

--

```tut:silent
def getDialCode(country: Country): DialCode = country match {
  case UnitedKingdom => _44
  case France        => _33
}
```

--

```tut:silent
def getCountry(dialCode: DialCode): Country = dialCode match {
  case _33 => France
  case _44 => France
}
```

---
# Example: dialCode

```tut:silent
getDialCode(UnitedKingdom) == _44
getCountry(_44)            == UnitedKingdom
```

--

```tut:invisible
import org.scalacheck.{Arbitrary, Gen}

implicit val arbCountry: Arbitrary[Country] = Arbitrary(Gen.oneOf(UnitedKingdom, France))
```

```tut:silent
class DialCodeTest extends FreeSpec with Checkers {

  "round trip" in check((x: Country) =>
    getCountry(getDialCode(x)) == x
  )

}
```

--

```scala
GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.
 (DialCodeTest.scala:10)
  Falsified after 2 successful property evaluations.
  Location: (DialCodeTest.scala:10)
  Occurred when passed generated values (
    arg0 = UnitedKingdom
  )
```

---
# Example: isAdult

```tut:silent
case class Person(name: String, age: Int)

def isAdult(p: Person): Boolean =
  p.age >= 18
```

```tut
isAdult(Person("John", 25))
isAdult(Person("Alice", 18))
isAdult(Person("Bob", 5))
```

--

```tut
isAdult(Person("George", -2))
```

---
# Refinement types

```tut:silent
import eu.timepit.refined._
import eu.timepit.refined.api.Refined
import eu.timepit.refined.auto._
import eu.timepit.refined.numeric._

type PosInt = Int Refined Positive

def isAdult(i: PosInt): Boolean =
  i.value >= 18
```

--

```tut
isAdult(5)
isAdult(22)
```

--

```tut:fail
isAdult(-2)
```

---
# |isAdult|

```scala
|Person => Boolean| = |Boolean| ^ |Person|
                    = 2 ^ (|String| * |Int|)
```

```scala
|PosInt => Boolean| = |Boolean| ^ |PosInt|
                    = 2 ^ (|Int| / 2)
```

---
class: center, middle

# Thanks!
Code and slides at `julien-truffaut/types-vs-tests` on GitHub

## Questions?

---
class: center, middle

# |A| ?

---
# Or

## `Boolean` is `true` **OR** `false`

--

## `Char` is `'a'` **OR** `'b'` **OR** ... **OR** `'!'` **OR** ...

--

## `DayOfTheWeek` is `Monday` **OR** `Tuesday` **OR** ...

--

## `Option[A]` is `None` **OR** a `Some[A]`

--

## `Either[E, A]` is a `Left[E]` **OR** a `Right[A]`


---
# Coproduct / Sum type

```scala
Foo is a Bar OR a Fizz

|Foo| = |Bar| + |Fizz|
```

--

```scala
|Boolean| = |true| + |false|
          = 1 + 1
          = 2
```

--

```scala
|Option[A]| = |None| + |Some[A]|
            = 1 + |A|
```

---
# And

## `LocalDate` is an `Int` (year) **AND** a `Short` (month) **AND** a `Short` (day)

--

## `Person` is a `String` (name) **AND** an `Int` (age)

--

## `(Int, String)` is an `Int` **AND** a `String`

---
# Product type

```scala
Foo is a Bar AND a Fizz

|Foo| = |Bar| * |Fizz|
```

--

```scala
|(Boolean, Char)| = |Boolean| * |Char|
                  = 2 * 256
                  = 512
```

--

```scala
|Person| = |String| * |Int|
```

---
class: center, middle

# Algebraic data type



 </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
        var slideshow = remark.create({
            ratio: "16:9"
        });
    </script>
  </body>
</html>
