<!DOCTYPE html>
<html>
  <head>
    <title>Types vs Tests</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .pull-left {
      float: left;
      width: 47%;
      }
      .pull-right {
      float: right;
      width: 47%;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Types vs Tests
`@JulienTruffaut`

---
class: center, middle

# Types

---
background-image: url(img/types-1.jpg)

# Types

---
background-image: url(img/types-2.jpg)

# Types

---
background-image: url(img/types-3.jpg)

# Types

---
# Values

```scala
val x: Int = 5

val foo: Boolean = true
```

--

```scala
scala> val y: Int = false
<console>:12: error: type mismatch;
 found   : Boolean(false)
 required: Int
       val y: Int = false
                    ^
```

---
background-image: url(img/function.jpg)

# Function

---
# Functional programming subset

* deterministic
* total
* no side effect
* no mutation
* no exception
* no null
* no reflection

---
# Function

```scala
def increment(x: Int): Int = x + 1
```

--

```scala
scala> increment(2)
res0: Int = 3

scala> increment(-5)
res1: Int = -4
```

--

```scala
scala> increment("hello")
<console>:14: error: type mismatch;
 found   : String("hello")
 required: Int
       increment("hello")
                 ^
```

---
class: center, middle

# Tests

---
class: center, middle

# Unit Test

---
# Unit Test

```scala
increment( 0) ==  1
increment( 1) ==  2
increment(-3) == -2
```

---
background-image: url(img/increment-math-unit-test-1.jpg)

# Unit Test

---
background-image: url(img/increment-math-unit-test-fail.jpg)

# Unit Test

---
background-image: url(img/increment-math-unit-test-2.jpg)

# Unit Test

---
class: center, middle

# Property Test

---
# Property Test

```scala
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers

class IncrementTest extends FreeSpec with Checkers {

  "f(x) > x" in check((x: Int) => increment(x) > x)

}
```

---
background-image: url(img/increment-math-property-test-1.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-2.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-fail.jpg)
# Property Test

---
background-image: url(img/increment-math-property-test-3.jpg)
# Property Test

---
# Property Test: edge cases

```scala
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers

class IncrementTest extends FreeSpec with Checkers {

  "f(x) > x" in check((x: Int) => increment(x) > x)

}
```

--

```scala
GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.
 (IncrementTest.scala:10)
  Falsified after 4 successful property evaluations.
  Location: (IncrementTest.scala:10)
  Occurred when passed generated values (
    arg0 = 2147483647
  )
```

```scala
scala> increment(2147483647)
res6: Int = -2147483648
```

---
# Property Test: edge cases


```scala
def increment(x: Int): Int = {
  if(x < Int.MaxValue) x + 1
  else x
}
```

```scala
scala> increment(5)
res7: Int = 6

scala> increment(2147483647)
res8: Int = 2147483647
```

---
# Property Test: refinement types

```scala
import eu.timepit.refined.numeric.Less
import org.scalatest.FreeSpec
import org.scalatest.prop.Checkers
import eu.timepit.refined.W
import eu.timepit.refined.api.Refined
import eu.timepit.refined.scalacheck.numeric._

class IncrementTest extends FreeSpec with Checkers {

  final val maxInt = Int.MaxValue

  "f(x) > x" in check((x: Int Refined Less[W.`maxInt`.T]) =>
    increment(x.value) > x.value
  )

}
```

---
class: center, middle

# Types and Tests

---

.pull-left[
# Types

```scala
scala> increment("hello")
<console>:28: error: type mismatch;
 found   : String("hello")
 required: Int
       increment("hello")
                 ^
```
]

.pull-right[
# Tests

```scala
import org.scalacheck.Prop.forAll

increment(0) == 1

forAll((x: Int) => increment(x) > x)
```
]

---
class: center, middle

# Both types and tests constrain the implementation of a function

---
class: center, middle

# How much?

---
class: center, middle

# A => B

---
class: middle

```scala
val isEven: Int => Boolean =
  x => x % 2 == 0

val increment: Int => Int =
  x => x + 1
```

---
background-image: url(img/A-to-B-set-1.jpg)

# Functions are sets!

---
background-image: url(img/A-to-B-set-2.jpg)

# Functions are sets!


---
background-image: url(img/int-to-int-type-1.jpg)

# Functions are sets!

---
background-image: url(img/int-to-int-type-test-1.jpg)

# Unit tests

---
background-image: url(img/int-to-int-type-test-2.jpg)

# Unit + Property tests

---
class: center, middle

# How to constrain a function?

---
background-image: url(img/A-to-B-constrain.jpg)

# Constraints

---
class: center, middle

# Smaller types


---
background-image: url(img/function-one-value.jpg)

# Single value function type

---
class: center, middle

# |A => B| == 1

---
class: middle

```scala
def boolToUnit(x: Boolean): Unit = x match {
  case true  => ()
  case false => ()
}
```

---
class: middle

```scala
def toUnit[A](x: A): Unit = ()
```

---
class: center, middle

# |A => B| ?

---
background-image: url(img/function.jpg)

# Function is a mapping

---
background-image: url(img/function-mapping-1.jpg)

# Function is a mapping

---
background-image: url(img/count-A-to-B-1.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-2.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-3.jpg)

# |A => B|

---
background-image: url(img/count-A-to-B-4.jpg)

# |A => B|

---
class: center, middle

```scala
|Int => Int| = |Int| ^ |Int|
               = (2^32) ^ (2^32)
```

--

```scala
|DayOfWeek => Boolean| = |Boolean| ^ |DayOfWeek|
     = 2 ^ 7
   = 128
```

---
class: center, middle

# More tests

---
background-image: url(img/day-week-to-boolean-1.jpg)

---
class: center, middle

# How many implementations a single unit test renders invalid?

---
background-image: url(img/day-week-to-boolean-2.jpg)

---
# Unit test

```scala
val f: DayOfWeek => Boolean = ???
```

such as

```scala
isWeekend(Tuesday) == false
```

---
background-image: url(img/count-day-week-to-boolean-1.jpg)

# Unit Test

---
background-image: url(img/count-day-week-to-boolean-2.jpg)

# Unit Test

---
background-image: url(img/count-day-week-to-boolean-3.jpg)

# Unit Test

---
background-image: url(img/count-day-week-to-boolean-4.jpg)

# Unit Test

---
class: center, middle

# A unit test divides the size of |A => B| by |B|

---
class: center, middle

# A function A => B requires `|A|` unit tests to be fully covered

---
class: middle

## 1. Functions are sets

## 2. Functions are constrained by using smaller types or more tests

## 3. `|A => B| = |B| ^ |A|`

## 4. Each unit test divides `|A => B|` by `|B|`


---
class: center, middle

# Examples

---
# Example: dialCode

```scala
def getDialCode(country: String): Int = ???
```

such as

```scala
getDialCode("United Kinkdom") == 44
getDialCode("France")         == 33
```

---
# Example: dialCode

```scala
def getDialCode(country: String): Int = country match {
  case "United Kinkdom" => 44
  case "France"         => 33
  case _                => ???
}
```

--

```scala
scala> getDialCode("United Kinkdom")
res12: Int = 44

scala> getDialCode("France")
res13: Int = 33
```

--

```scala
scala> getDialCode("Italy")
scala.NotImplementedError: an implementation is missing
  at scala.Predef$.$qmark$qmark$qmark(Predef.scala:284)
  at .getDialCode(<console>:30)
  ... 43 elided
```

---
# Example: dialCode

```scala
def getDialCode(country: String): Option[Int] = country match {
  case "United Kinkdom" => Some(44)
  case "France"         => Some(33)
  case _                => None
}
```

--

```scala
scala> getDialCode("United Kinkdom")
res15: Option[Int] = Some(44)

scala> getDialCode("France")
res16: Option[Int] = Some(33)

scala> getDialCode("Italy")
res17: Option[Int] = None
```

--

```scala
scala> getDialCode("UK")
res18: Option[Int] = None

scala> getDialCode("Royaume Uni")
res19: Option[Int] = None
```

---
# Example: dialCode

```scala
sealed trait Country

case object UnitedKingdom extends Country
case object France extends Country
```

--

```scala
def getDialCode(country: Country): Int = country match {
  case UnitedKingdom => 44
  case France        => 33
}
```

--

```scala
scala> getDialCode(UnitedKingdom)
res20: Int = 44
```

```scala
scala> getDialCode(Italy)
<console>:29: error: not found: value Italy
       getDialCode(Italy)
                   ^
```

---
# Example: dialCode

```scala
sealed trait Country

case object UnitedKingdom extends Country
case object France extends Country
case object Italy extends Country
```

```scala
def getDialCode(country: Country): Int = country match {
  case UnitedKingdom => 44
  case France        => 33
}
```

--

```scala
Warning:(11, 44) match may not be exhaustive.
It would fail on the following input: Italy
  def getDialCode(country: Country): Int = country match {
```

---
# Example: dialCode

```scala
def parseCountry(x: String): Option[Country] = ???
```

such as

```scala
parseCountry("United Kingdom") == Some(UnitedKingdom)
parseCountry("UK")             == Some(UnitedKingdom)
```

---
# Example: dialCode

```scala
|String => Option[Int]| = |Option[Int]| ^ |String|
                        = (|Int| + 1) ^ |String|
```

--

```scala
|Country => Int| = |Int| ^ |Country|
                 = |Int| ^ 2
```

--

```scala
|Country => DialCode| = |DialCode| ^ |Country|
                      = 2 ^ 2
                      = 4
```

---
# Example: dialCode

```scala
sealed trait DialCode

object _33 extends DialCode
object _44 extends DialCode
```

--

```scala
def getDialCode(country: Country): DialCode = country match {
  case UnitedKingdom => _44
  case France        => _33
}
```

--

```scala
def getCountry(dialCode: DialCode): Country = dialCode match {
  case _33 => France
  case _44 => France
}
```

---
# Example: dialCode

```scala
scala> getDialCode(France)
res22: DialCode = _33$@2c6e750b

scala> getCountry(_33)
res23: Country = France
```

--




```scala
class DialCodeTest extends FreeSpec with Checkers {

  "round trip" in check((x: Country) =>
    getCountry(getDialCode(x)) == x
  )

}
```

--

```scala
GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.
 (DialCodeTest.scala:10)
  Falsified after 2 successful property evaluations.
  Location: (DialCodeTest.scala:10)
  Occurred when passed generated values (
    arg0 = UnitedKingdom
  )
```

---
# Example: Person

```scala
case class Person(name: String, age: Int) {
  require(age >= 0, "age must be positive")
}
```

--

```scala
scala> Person("John", 25)
res24: Person = Person(John,25)

scala> Person("Alice", 12)
res25: Person = Person(Alice,12)
```

--

```scala
scala> Person("George", -2)
java.lang.IllegalArgumentException: requirement failed: age must be positive
  at scala.Predef$.require(Predef.scala:277)
  ... 44 elided
```

---
# Example: Person with smart constructor

```scala
case class Person(name: String, age: Int)

def mkPerson(name: String, age: Int): Option[Person] = {
  if(age < 0) None
  else Some(Person(name, age))
}
```

--

```scala
scala> mkPerson("John", 25)
res27: Option[Person] = Some(Person(John,25))

scala> mkPerson("Alice", 12)
res28: Option[Person] = Some(Person(Alice,12))

scala> mkPerson("George", -2)
res29: Option[Person] = None
```

---
# Example: Person with refinement types

```scala
import eu.timepit.refined._
import eu.timepit.refined.api.Refined
import eu.timepit.refined.auto._
import eu.timepit.refined.numeric._

type PosInt = Int Refined Positive

case class Person(name: String, age: PosInt)
```

--

```scala
scala> Person("John", 25)
res30: Person = Person(John,25)

scala> Person("Alice", 12)
res31: Person = Person(Alice,12)
```

--

```scala
scala> Person("George", -2)
<console>:42: error: Predicate failed: (-2 > 0).
       Person("George", -2)
                        ^
```

---
# Review

## 1. Use smallest type as possible

## 2. Use tests (unit + property) to cover the remain cases

---
# Next step

```scala
def mapInt(fa: Option[Int])(f: Int => Int): Option[Int] = ???

def map[A, B](fa: Option[A])(f: A => B): Option[B] = ???
```

---
class: center, middle

# Thanks!
Code and slides at `julien-truffaut/types-vs-tests` on GitHub

## Questions?

 </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
        var slideshow = remark.create({
            ratio: "16:9"
        });
    </script>
  </body>
</html>
